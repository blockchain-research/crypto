/*
WORk IN PROGRESS
*/
package brs

import (
	"crypto/rand"
	"math/big"

	"github.com/btcsuite/btcd/btcec"
)

type ParamsUL struct {
	curve *btcec.KoblitzCurve
	hx    *big.Int
	hy    *big.Int
	u     int64
	l     int64
}

/*
ProofUL contains the proof generated by prover which will be used for verification by verifiers
*/
type ProofUL struct {
	e0 *big.Int
	C  [][]*big.Int
	s  [][]*big.Int
	m  []*big.Int
}

func SetupUL(u, l int64) *ParamsUL {
	h := GetBigInt("18560948149108576432482904553159745978835170526553990798435819795989606410925")
	curve := btcec.S256()
	hx, hy := curve.ScalarBaseMult(h.Bytes())
	return &ParamsUL{
		curve: curve,
		hx:    hx,
		hy:    hy,
		u:     u,
		l:     l,
	}

}

//v is the number to prove in range [0,u^l)
func (p *ParamsUL) ProveUL(number *big.Int) (*ProofUL, *big.Int) {
	//initialize e l * u
	e := make([][]*big.Int, p.l)
	for i := range e {
		e[i] = make([]*big.Int, p.u)
	}

	//initialize R l * 2
	var R = make([][]*big.Int, p.l)
	for i := range R {
		R[i] = make([]*big.Int, 2)
	}

	//initialize k len: l
	var k = make([]*big.Int, p.l)

	//initialize karr l*u
	var karr = make([][]*big.Int, p.l)
	for i := range karr {
		karr[i] = make([]*big.Int, p.u)
	}

	//initialize C l*2
	var C = make([][]*big.Int, p.l)
	for i := range C {
		C[i] = make([]*big.Int, 2)
	}

	//initialize s l * u
	var s = make([][]*big.Int, p.l)
	for i := range s {
		s[i] = make([]*big.Int, p.u)
	}

	//initialize rsum
	rsum := new(big.Int).SetInt64(0)
	//initialize r len: l
	var r = make([]*big.Int, p.l)

	//Step 1
	v, m := GetBaseRepresentation(number, p.u, p.l)

	//Step 2
	var i, j int64
	for i = 0; i < p.l; i++ {
		if v[i].Sign() == 0 {
			//random k^i_0 from Zq
			karr[i][0], _ = rand.Int(rand.Reader, p.curve.N)
			//set R^i = k^i_0G,
			R[i][0], R[i][1] = p.curve.ScalarBaseMult(karr[i][0].Bytes())

		} else {
			//random r^i from Zq
			r[i], _ = rand.Int(rand.Reader, p.curve.N)
			rsum = new(big.Int).Add(rsum, r[i])

			//C^i = commit(m^iv^i,r^i)
			mvi := new(big.Int).Mul(m[i], v[i])
			C[i][0], C[i][1] = Commit(mvi, r[i], p.hx, p.hy)

			// random k_^i from Zq
			k[i], _ = rand.Int(rand.Reader, p.curve.N)

			// compute e^i_vi=H(k^iG)
			kiGx, kiGy := p.curve.ScalarBaseMult(k[i].Bytes())
			e[i][v[i].Int64()] = Hash([]*big.Int{kiGx, kiGy})

			//for each j \in {v^i+1,...,m-1}
			for j = v[i].Int64() + 1; j < p.u; j++ {
				//random sij from Zq
				s[i][j], _ = rand.Int(rand.Reader, p.curve.N)

				//calculate s^i_jG
				p1x, p1y := p.curve.ScalarBaseMult(s[i][j].Bytes())

				//calculate -eC
				eneg := new(big.Int).Neg(e[i][j-1])
				eneg = new(big.Int).Mod(eneg, p.curve.N)
				prodCx, prodCy := p.curve.ScalarMult(C[i][0], C[i][1], eneg.Bytes())

				//calculate sG-eC
				p2x, p2y := p.curve.Add(p1x, p1y, prodCx, prodCy)

				//calculate ejmH
				prod := new(big.Int).Mul(e[i][j-1], new(big.Int).Mul(new(big.Int).SetInt64(j), m[i]))
				prod = prod.Mod(prod, p.curve.N)
				prodHx, prodHy := p.curve.ScalarMult(p.hx, p.hy, prod.Bytes())

				//calculate s^i_jG-e^i_j-1[C^i-jm^iH]
				px, py := p.curve.Add(p2x, p2y, prodHx, prodHy)

				//compute eij= H(s^i_jG-e^i_j-1[C^i-jm^iH])
				e[i][j] = Hash([]*big.Int{px, py})
			}

			//compute R^i = e^i_m-1C^1
			R[i][0], R[i][1] = p.curve.ScalarMult(C[i][0], C[i][1], e[i][p.u-1].Bytes())

		}
	}

	//Step 3: set e0=H(R0||..||Rn-1)
	var Rslice = make([]*big.Int, p.l*2)
	for i = 0; i < p.l; i++ {
		Rslice[2*i] = R[i][0]
		Rslice[2*i+1] = R[i][1]
	}
	e0 := Hash(Rslice)

	//Step 4:
	for i = 0; i < p.l; i++ {
		e[i][0] = e0
		if v[i].Sign() == 0 {
			//for j \in {1...,m-1}
			for j = 1; j < p.u; j++ {
				//random k^i_j from Zq
				karr[i][j], _ = rand.Int(rand.Reader, p.curve.N)

				//kijG
				kGx, kGy := p.curve.ScalarBaseMult(karr[i][j].Bytes())

				//e^i_j-1m^ij
				emj := new(big.Int).Mul(new(big.Int).Mul(e[i][j-1], m[i]), new(big.Int).SetInt64(j))
				emj = new(big.Int).Mod(emj, p.curve.N)

				//e^i_j-1m^ijH
				emjHx, emjHy := p.curve.ScalarMult(p.hx, p.hy, emj.Bytes())

				//ijG+e^i_j-1m^ijH
				px, py := p.curve.Add(kGx, kGy, emjHx, emjHy)

				//e[i][j]=H(kijG+e^i_j-1m^ijH)
				e[i][j] = Hash([]*big.Int{px, py})
			}

			//compute C^i = R^i / e^i_m-1
			einverse := new(big.Int).ModInverse(e[i][p.u-1], p.curve.N)
			keinverse := new(big.Int).Mul(karr[i][0], einverse)
			keinverse = new(big.Int).Mod(keinverse, p.curve.N)
			rsum = new(big.Int).Add(rsum, keinverse)
			C[i][0], C[i][1] = p.curve.ScalarBaseMult(keinverse.Bytes())

			//for j \in {1...,m-1}
			for j = 1; j < p.u; j++ {
				ke := new(big.Int).Mul(karr[i][0], e[i][j-1])
				einverse := new(big.Int).ModInverse(e[i][p.u-1], p.curve.N)
				kee := new(big.Int).Mul(ke, einverse)

				s[i][j] = new(big.Int).Add(karr[i][j], kee)
				s[i][j] = new(big.Int).Mod(s[i][j], p.curve.N)
			}
		} else {
			//for j \in {1...,m-1}
			for j = 1; j < v[i].Int64(); j++ {
				//random sij from Zq
				s[i][j], _ = rand.Int(rand.Reader, p.curve.N)

				//calculate s^i_jG
				p1x, p1y := p.curve.ScalarBaseMult(s[i][j].Bytes())

				//calculate -eC
				eneg := new(big.Int).Neg(e[i][j-1])
				eneg = new(big.Int).Mod(eneg, p.curve.N)
				prodCx, prodCy := p.curve.ScalarMult(C[i][0], C[i][1], eneg.Bytes())

				//calculate sG-eC
				p2x, p2y := p.curve.Add(p1x, p1y, prodCx, prodCy)

				//calculate ejmH
				prod := new(big.Int).Mul(e[i][j-1], new(big.Int).Mul(new(big.Int).SetInt64(j), m[i]))
				prod = prod.Mod(prod, p.curve.N)
				prodHx, prodHy := p.curve.ScalarMult(p.hx, p.hy, prod.Bytes())

				//calculate s^i_jG-e^i_j-1[C^i-jm^iH]
				px, py := p.curve.Add(p2x, p2y, prodHx, prodHy)

				//compute eij= H(s^i_jG-e^i_j-1[C^i-jm^iH])
				e[i][j] = Hash([]*big.Int{px, py})
			}
			//set s^i_vi = k^i + e^i_vi-1r^i
			eri := new(big.Int).Mul(e[i][v[i].Int64()-1], r[i])
			s[i][v[i].Int64()] = new(big.Int).Add(k[i], eri)
			s[i][v[i].Int64()] = new(big.Int).Mod(s[i][v[i].Int64()], p.curve.N) //?optional?

		}
	}

	//Step 5:
	return &ProofUL{
		e0: e0,
		C:  C,
		s:  s,
		m:  m,
	}, rsum
}

func (v *ParamsUL) VerifyUL(proof *ProofUL, cmx *big.Int, cmy *big.Int) bool {
	var i, j int64
	//initialize e l * u
	var e = make([][]*big.Int, v.l)
	for i := range e {
		e[i] = make([]*big.Int, v.u)
	}

	//initialize R l * 2
	var R = make([][]*big.Int, v.l)
	for i := range R {
		R[i] = make([]*big.Int, 2)
	}

	//Step 1
	for i = 0; i < v.l; i++ {
		e[i][0] = proof.e0
		for j = 1; j < v.u; j++ {
			//calculate s^i_jG
			p1x, p1y := v.curve.ScalarBaseMult(proof.s[i][j].Bytes())

			//calculate -eC
			eneg := new(big.Int).Neg(e[i][j-1])
			eneg = new(big.Int).Mod(eneg, v.curve.N)
			prodCx, prodCy := v.curve.ScalarMult(proof.C[i][0], proof.C[i][1], eneg.Bytes())

			//calculate sG-eC
			p2x, p2y := v.curve.Add(p1x, p1y, prodCx, prodCy)

			//calculate ejmH
			prod := new(big.Int).Mul(e[i][j-1], new(big.Int).Mul(new(big.Int).SetInt64(j), proof.m[i]))
			prod = prod.Mod(prod, v.curve.N)
			prodHx, prodHy := v.curve.ScalarMult(v.hx, v.hy, prod.Bytes())

			//calculate s^i_jG-e^i_j-1[C^i-jm^iH]
			px, py := v.curve.Add(p2x, p2y, prodHx, prodHy)

			//compute eij= H(s^i_jG-e^i_j-1[C^i-jm^iH])
			e[i][j] = Hash([]*big.Int{px, py})
		}
		//compute R^i = e^i_m-1C^1
		R[i][0], R[i][1] = v.curve.ScalarMult(proof.C[i][0], proof.C[i][1], e[i][v.u-1].Bytes())
	}

	//Step 2:set ehat0=H(R0||..||Rn-1)
	var Rslice = make([]*big.Int, v.l*2)
	for i = 0; i < v.l; i++ {
		Rslice[2*i] = R[i][0]
		Rslice[2*i+1] = R[i][1]
	}
	ehat0 := Hash(Rslice)

	if proof.e0.Cmp(ehat0) != 0 {
		return false
	}

	//Step3: calculate commitment c = sum(Ci)
	cSumx := new(big.Int).Set(proof.C[0][0])
	cSumy := new(big.Int).Set(proof.C[0][1])
	for i = 1; i < v.l; i++ {
		cSumx, cSumy = v.curve.Add(cSumx, cSumy, proof.C[i][0], proof.C[i][1])
	}

	if cSumx.Cmp(cmx) != 0 {
		return false
	}
	if cSumy.Cmp(cmy) != 0 {
		return false
	}

	return true
}
